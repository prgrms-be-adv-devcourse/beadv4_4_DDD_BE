name: CD Pipeline

on:
  push:
    tags:
      # [모듈명]-v[버전] 형식의 태그가 푸시될 때만 작동합니다.
      - '*-v*.*.*'

permissions:
  contents: read

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

jobs:
  deploy:
    name: Build & Deploy
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 1. 태그가 main 브랜치에 있는지 검증
      - name: Verify Tag is on main branch
        run: |
          echo "태그가 main 브랜치에 속해 있는지 검증합니다..."
          git fetch origin main
          
          if ! git branch -r --contains ${{ github.sha }} | grep -q "origin/main"; then
            echo "[배포 차단] 이 태그는 main 브랜치에 존재하지 않습니다!"
            exit 1
          fi
          echo "태그가 main 브랜치에 포함된 것을 확인했습니다."

      # 2. 태그 이름표를 분석하여 모듈명과 버전 추출
      - name: Parse Tag and Determine Module
        id: parse
        run: |
          # 예: refs/tags/member-v1.0.2 -> member-v1.0.2
          TAG_NAME=${GITHUB_REF#refs/tags/}
          
          # '-v'를 기준으로 앞부분은 모듈명, 뒷부분은 버전(숫자)으로 분리
          MODULE_PREFIX=${TAG_NAME%-v*}
          VERSION=${TAG_NAME#*-v}
          
          echo "MODULE_PREFIX=$MODULE_PREFIX" >> $GITHUB_ENV
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "Target Module: $MODULE_PREFIX / Version: $VERSION"
          
          # 백엔드인지 프론트엔드인지 판별
          VALID_BACKENDS=("api-gateway" "settlement" "member" "payment" "order" "product" "file" "inventory")
          IS_BACKEND=false
          for m in "${VALID_BACKENDS[@]}"; do
            if [ "$m" == "$MODULE_PREFIX" ]; then
              IS_BACKEND=true
              break
            fi
          done
          
          if [ "$MODULE_PREFIX" == "web-client" ]; then
            echo "BUILD_FRONTEND=true" >> $GITHUB_ENV
          elif [ "$IS_BACKEND" == "true" ]; then
            echo "BUILD_BACKEND=true" >> $GITHUB_ENV
            echo "BACKEND_MODULE=${MODULE_PREFIX}-service" >> $GITHUB_ENV
          else
            echo "알 수 없는 모듈 태그입니다: $MODULE_PREFIX"
            echo "사용 가능한 모듈명: web-client, api-gateway, member 등"
            exit 1
          fi

      - name: Set up JDK 21 (백엔드인 경우)
        if: env.BUILD_BACKEND == 'true'
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: 'gradle'

      - name: Docker login
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # 3. [백엔드] 지정된 단일 모듈만 빌드 및 푸시
      - name: Build and push backend image
        if: env.BUILD_BACKEND == 'true'
        run: |
          chmod +x gradlew
          echo "====================================="
          echo "Building Backend: ${{ env.BACKEND_MODULE }}"
          echo "====================================="
          
          IMAGE_NAME="${{ secrets.DOCKER_USERNAME }}/modeunsa-${{ env.MODULE_PREFIX }}"
          
          ./gradlew :${{ env.BACKEND_MODULE }}:bootBuildImage --imageName=$IMAGE_NAME:${{ env.VERSION }}
          docker push $IMAGE_NAME:${{ env.VERSION }}

      # 4. [프론트엔드] 프론트엔드 빌드 및 푸시
      - name: Build and push frontend image
        if: env.BUILD_FRONTEND == 'true'
        run: |
          echo "====================================="
          echo "Building Frontend (web-client)"
          echo "====================================="
          IMAGE_NAME="${{ secrets.DOCKER_USERNAME }}/modeunsa-web-client"
          
          docker build -t $IMAGE_NAME:${{ env.VERSION }} ./web-client
          docker push $IMAGE_NAME:${{ env.VERSION }}

      # 5. k8s 디렉토리 복사
      - name: Copy k8s directory to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ec2-user
          key: ${{ secrets.EC2_KEY }}
          source: "k8s/"
          target: "/home/ec2-user/app"

      # 6. EC2 접속 후 해당 모듈만 .env 파일 업데이트 및 배포
      - name: Update .env.k3s-prod and Deploy on EC2
        uses: appleboy/ssh-action@v1.0.3
        env:
          VERSION: ${{ env.VERSION }}
          MODULE_PREFIX: ${{ env.MODULE_PREFIX }}
          BUILD_BACKEND: ${{ env.BUILD_BACKEND }}
          BUILD_FRONTEND: ${{ env.BUILD_FRONTEND }}
          DOCKER_USER: ${{ secrets.DOCKER_USERNAME }}
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ec2-user
          key: ${{ secrets.EC2_KEY }}
          envs: VERSION,MODULE_PREFIX,BUILD_BACKEND,BUILD_FRONTEND,DOCKER_USER
          script: |
            set -e
            cd /home/ec2-user/app
            
            if [ "$BUILD_BACKEND" == "true" ]; then
              # 모듈명을 환경변수 키로 변환 (예: api-gateway -> API_GATEWAY_IMAGE)
              ENV_KEY=$(echo "$MODULE_PREFIX" | tr 'a-z-' 'A-Z_')_IMAGE
              NEW_IMAGE="${DOCKER_USER}/modeunsa-${MODULE_PREFIX}:${VERSION}"
            
              if grep -q "^${ENV_KEY}=" .env.k3s-prod; then
                sed -i "s|^${ENV_KEY}=.*|${ENV_KEY}=${NEW_IMAGE}|" .env.k3s-prod
              else
                echo "${ENV_KEY}=${NEW_IMAGE}" >> .env.k3s-prod
              fi
              echo "Updated $ENV_KEY to $NEW_IMAGE"
            fi
            
            if [ "$BUILD_FRONTEND" == "true" ]; then
              NEW_FRONTEND_IMAGE="${DOCKER_USER}/modeunsa-web-client:${VERSION}"
              if grep -q "^FRONTEND_IMAGE=" .env.k3s-prod; then
                sed -i "s|^FRONTEND_IMAGE=.*|FRONTEND_IMAGE=${NEW_FRONTEND_IMAGE}|" .env.k3s-prod
              else
                echo "FRONTEND_IMAGE=${NEW_FRONTEND_IMAGE}" >> .env.k3s-prod
              fi
              echo "Updated FRONTEND_IMAGE to $NEW_FRONTEND_IMAGE"
            fi
            
            chmod +x ./k8s/*.sh
            sudo ./k8s/app.sh up prod